/********************************************************************************
** Copyright TOTVS S.A. (2015)
** Todos os Direitos Reservados.
**
** Este fonte e de propriedade exclusiva da TOTVS, sua reproducao
** parcial ou total por qualquer meio, so podera ser feita mediante
** autorizacao expressa.
********************************************************************************/

/********************************************************************************
** Programa.: GpsUtils.cls
**
** Data.....: 08/07/2019
**
** Criacao..: Contratos
**
** Objetivo.: Tratamentos padroes utilizados nas APIs
********************************************************************************/

using progress.json.ObjectModel.*.

class classes.utils.GpsUtils:    
    
    /* --- Metodos privados -------------------------------------------------------------------------------- */
    method private char databaseFieldName (input hTable as handle, input fieldName as character):

        define variable ix as integer no-undo.
        
        repeat ix = 1 to hTable:num-fields:
            if hTable:buffer-field(ix):serialize-name = fieldName
            then return hTable:buffer-field(ix):name.
        end.
        return fieldName.
    
    end method.
    
    method private char hex2char(input phex as character):
 
        def var cchar1  as char no-undo.
        def var cchar2  as char no-undo.
        def var cstring as char initial "ABCDEF" no-undo.
        def var idigit  as int  no-undo.  
    
        assign cchar1 = substring(phex, 1, 1)
               idigit = (if index(cstring, cchar1) = 0 
                         then integer(cchar1)
                         else index(cstring, cchar1) + 9)
               idigit = idigit * 16
               cchar2 = substring(phex, 2, 1)
               idigit = (if index(cstring, cchar2) = 0 
                         then integer(cchar2)
                         else index(cstring, cchar2) + 9) 
                      + idigit.
    
        return chr(idigit).
    
    end method.

    /* --- Metodos estaticos ------------------------------------------------------------------------------- */
    method public static character getSeparators (input dsSearchText as character):

        if num-entries(dsSearchText, "/") = 2
        or num-entries(dsSearchText, "/") = 3
        then return "/".

        if num-entries(dsSearchText, "~\") = 2
        or num-entries(dsSearchText, "~\") = 3
        then return "~\".

        if num-entries(dsSearchText, ";") = 2
        or num-entries(dsSearchText, ";") = 3
        then return ";".

        if length(dsSearchText) <= 13
        then do:
            if num-entries(dsSearchText, "-") = 2
            or num-entries(dsSearchText, "-") = 3
            then return "-".
        end.

        if num-entries(dsSearchText, ",") = 2
        or num-entries(dsSearchText, ",") = 3
        then return ",".

    end method.

    /* --- Metodos publicos -------------------------------------------------------------------------------- */
    method public character getSeparator (input dsSearchText as character):

        if num-entries(dsSearchText, "/") = 2
        or num-entries(dsSearchText, "/") = 3
        then return "/".

        if num-entries(dsSearchText, "~\") = 2
        or num-entries(dsSearchText, "~\") = 3
        then return "~\".

        if num-entries(dsSearchText, ";") = 2
        or num-entries(dsSearchText, ";") = 3
        then return ";".

        if length(dsSearchText) <= 13
        then do:
            if num-entries(dsSearchText, "-") = 2
            or num-entries(dsSearchText, "-") = 3
            then return "-".
        end.

        if num-entries(dsSearchText, ",") = 2
        or num-entries(dsSearchText, ",") = 3
        then return ",".

    end method.

    method public decimal charToDec(input dsString as char):
        def var sResult as char initial "" no-undo.
        def var sPos    as char            no-undo.
        def var iPos    as int             no-undo.

        repeat iPos = 1 to length(dsString):
            assign sPos = substring(dsString, iPos, 1).
            if  sPos >= "0"
            and sPos <= "9"
            then assign sResult = sResult + sPos.
        end.

        if sResult = ""
        then return ?.
        return decimal(sResult).
    end method.

    method public date changeISOToDate (input cDate as char):

        define variable cDateISO    as character no-undo.
        define variable dtResult    as date      no-undo.
    
        assign cDateISO = entry(1,cDate,'T')
               dtResult = date(int(entry(2,cDateISO,'-')), int(entry(3,cDateISO,'-')), int(entry(1,cDateISO,'-'))).

        return dtResult.

    end method.

    method public void convertQueryParamToTable (input oJson as JsonObject, input hTable as handle):
        define variable ix                     as integer   initial 1 no-undo.
        define variable fieldNames             as character extent    no-undo.
        define variable serializeName          as character           no-undo.
        define variable cValue                 as character           no-undo.
        define variable isValidHandle          as logical initial no  no-undo.

        hTable:buffer-create().
        assign fieldNames = oJson:getnames().

        do ix = 1 to extent(fieldNames):

            assign serializeName = this-object:databaseFieldName(hTable, fieldNames[ix]). 

            assign isValidHandle = valid-handle(hTable:buffer-field(serializeName)) no-error.
            
            if not isValidHandle
            or error-status:error
            then next.
            else do:
                assign cValue = oJson:GetJsonArray(fieldNames[ix]):getcharacter(1).
                case hTable:buffer-field(serializeName):data-type:
                    
                    when "decimal"
                    then hTable:buffer-field(serializeName):buffer-value() = decimal(cValue).

                    when "integer"
                    then hTable:buffer-field(serializeName):buffer-value() = integer(cValue).

                    when "logical"
                    then hTable:buffer-field(serializeName):buffer-value() = logical(cValue).
                            
                    when "date"
                    then hTable:buffer-field(serializeName):buffer-value() = this-object:changeISOToDate(cValue).

                    when "rowid"
                    then hTable:buffer-field(serializeName):buffer-value() = this-object:convertBase64ToRowid(cValue).
                            
                    when "character"
                    then hTable:buffer-field(serializeName):buffer-value() = cValue.
                        
                end.
            end.
        end.

    end method.

    method public void convertJsonObjectsToTable (input oJson as JsonObject, input hTable as handle):
        define variable ix                     as integer   initial 1 no-undo.
        define variable iArray                 as integer             no-undo.
        define variable fieldNames             as character extent    no-undo.
        define variable serializeName          as character           no-undo.
        define variable cValue                 as character           no-undo.
        define variable isValidHandle          as logical initial no  no-undo.

        hTable:buffer-create().
        assign fieldNames = oJson:getnames().

        do ix = 1 to extent(fieldNames):

            assign serializeName = this-object:databaseFieldName(hTable, fieldNames[ix]). 

            assign isValidHandle = valid-handle(hTable:buffer-field(serializeName)) no-error.
            
            if not isValidHandle
            or error-status:error
            then next.
            else do:
                case oJson:GetType(fieldNames[ix]):
                    when JsonDataType:number
                    then do:
                        case hTable:buffer-field(serializeName):data-type:
                            when "Integer"
                                then hTable:buffer-field(serializeName):buffer-value() = oJson:getInteger(fieldNames[ix]).
                            when "Decimal"
                                then hTable:buffer-field(serializeName):buffer-value() = oJson:getDecimal(fieldNames[ix]).
                            otherwise 
                                hTable:buffer-field(serializeName):buffer-value() = string(oJson:getDecimal(fieldNames[ix])).
                        end case.
                    end.
                    when JsonDataType:boolean 
                        then hTable:buffer-field(serializeName):buffer-value() = oJson:getlogical(fieldNames[ix]).
                    when JsonDataType:string 
                        then do:
                                case hTable:buffer-field(serializeName):data-type:
                                    when "Date"
                                        then hTable:buffer-field(serializeName):buffer-value() = oJson:getDate(fieldNames[ix]).
                                    when "Integer"
                                        then hTable:buffer-field(serializeName):buffer-value() = integer(oJson:getcharacter(fieldNames[ix])).
                                    when "Decimal"
                                        then hTable:buffer-field(serializeName):buffer-value() = decimal(oJson:getcharacter(fieldNames[ix])).
                                    when "Rowid"
                                        then hTable:buffer-field(serializeName):buffer-value() = this-object:convertBase64ToRowid(oJson:getcharacter(fieldNames[ix])).
                                    otherwise 
                                        hTable:buffer-field(serializeName):buffer-value() = oJson:getcharacter(fieldNames[ix]).
                                end case.
                            end.
                    when JsonDataType:object 
                        then next.
                    when JsonDataType:array 
                        then do:
                            do iArray = 1 to oJson:GetJsonArray(fieldNames[ix]):length:
                                case hTable:buffer-field(serializeName):data-type:
                                    when "Integer"
                                        then hTable:buffer-field(serializeName):buffer-value(iArray) = oJson:getJsonArray(fieldNames[ix]):getInteger(iArray).
                                    when "Decimal"
                                        then hTable:buffer-field(serializeName):buffer-value(iArray) = oJson:getJsonArray(fieldNames[ix]):getDecimal(iArray).
                                    when "Rowid"
                                        then hTable:buffer-field(serializeName):buffer-value(iArray) = this-object:convertBase64ToRowid(oJson:getJsonArray(fieldNames[ix]):getCharacter(iArray)).
                                    otherwise 
                                        hTable:buffer-field(serializeName):buffer-value(iArray) = oJson:getJsonArray(fieldNames[ix]):getcharacter(iArray).
                                end case.
                            end.
                        end.
                    otherwise next.
                end.
            end.
        end.

    end method.

    method public void convertJsonArrayToTable (input oJson as JsonArray, input hTable as handle):
        def var iCount as int no-undo.
        do iCount = 1 to oJson:length:            
            this-object:convertJsonObjectsToTable(oJson:getJsonObject(iCount), hTable).
        end.   
    end method.

    method public char normalizePath (input cPath as char):
        assign cPath = replace(cPath, "~\", "/").
        if r-index(cPath, "/") < length(cPath)
        then assign cPath = cPath + "/".
        return cPath.
    end method.

    method public char fileBasename (input cFile as char):
        assign cFile = replace(cFile, "~\", "/").
        return substring(cFile, r-index(cFile, "/") + 1).
    end method.

    method public void mkDir (input cPath as char):
        def var cPrevPath     as char no-undo.
        def var cPathBasename as char no-undo.

        assign cPath = this-object:normalizePath(cPath)
               cPathBasename = substring(cPath, 1, length(cPath) - 1)
               file-info:file-name = cPathBasename.

        if index(cPathBasename, "/") = 0
        then leave.

        if file-info:full-pathname = ?
        then do:
            assign cPrevPath = substring(cPath, 1, r-index(cPathBasename, "/")).
            this-object:mkDir(cPrevPath).
            os-create-dir value(cPath).
        end.

    end method.

    /* Metodo SplitInteger com suas variacoes */
    method public log splitInteger(input cValue as char, output iValue1 as int):
        def var iValue2 as int init ? no-undo.
        def var iValue3 as int init ? no-undo.
        return this-object:splitInteger(cValue, output iValue1, output iValue2, output iValue3).
    end method.

    method public log splitInteger(input cValue as char, output iValue1 as int, output iValue2 as int):
        def var iValue3 as int init ? no-undo.
        return this-object:splitInteger(cValue, output iValue1, output iValue2, output iValue3).
    end method.

    method public log splitInteger(input cValue as char, output iValue1 as int, output iValue2 as int, output iValue3 as int):
        def var cSeparator  as char no-undo.
        def var iEntries    as int  no-undo.

        assign cSeparator = this-object:getSeparator(cValue)
               iEntries   = num-entries(cValue, cSeparator).
        
        assign iValue1 = int(entry(1, cValue, cSeparator))
               iValue2 = int(entry(2, cValue, cSeparator))
               iValue3 = int(entry(3, cValue, cSeparator)) no-error.

        return true.

    end method.

    method public char decodeURL(input purl as character):
    
        def var cchar as char no-undo.
        def var curl  as char no-undo.
        def var cx    as char no-undo.
        def var cy    as char no-undo.
        def var ix    as int  no-undo.  
        def var iy    as int  initial 1 no-undo.
    
        do ix = 1 to length(purl):
            assign cy = substring(purl, iy, 1)
                   cx = cy.
    
            if cx = "%" 
            then assign cchar = this-object:hex2char(substring(purl, iy + 1, 2))
                        iy    = iy + 2.
            else assign cchar = cx.
    
            assign curl = curl + cchar
                   iy   = iy + 1.
        end.
    
        return curl.
    
    end method.

    /* Remove tags do XML e retorna apenas o conteudo de texto */
    method public longchar removeXmlTags(input lcText as longchar):
        def var iSize as int no-undo.
        def var mSource as memptr no-undo.

        if lcText = ?
        or lcText = ""
        then return "".

        assign iSize = length(lcText).
        set-size(mSource) = iSize.
        copy-lob from lcText to mSource.

        return this-object:removeXmlTags(mSource).
    end method.    

    method public longchar removeXmlTags(input mSource as memptr):
        def var isTag as log init false no-undo.
        def var iPos as int no-undo.
        def var iSize as int no-undo.
        def var iTargetPos as int init 0 no-undo.
        def var lcResult as longchar init "" no-undo.
        def var chPos as char no-undo.
        def var mTarget as memptr no-undo.

        assign iSize = get-size(mSource).

        if iSize = 0
        then return "".

        set-size(mTarget) = iSize.
        
        do iPos = 1 to iSize:
            assign chPos = get-string(mSource, iPos, 1).

            if isTag
            then do:
                if chPos = ">"
                then assign isTag = false.
            end.
            else do:
                if chPos = "<"
                then assign isTag = true.
                else do:
                    assign iTargetPos = iTargetPos + 1.
                    put-string(mTarget, iTargetPos, 1) = chPos.
                end.
            end.
        end.

        if iTargetPos > 0
        then copy-lob from mTarget for iTargetPos to lcResult.
        else assign lcResult = "".

        return lcResult.
    end method.

    /* ---------------------------------- FUNCAO PARA REMOVER DE CARACTERES --- */
    /* ----------------------------------- ESPECIAIS EM UMA STRING QUALQUER --- */
    method public longchar removeCharEspecial(input ds-conversao-par as longchar).

        define variable ds-especial-aux  as character                no-undo.
        define variable nr-char-aux      as integer                  no-undo.
        define variable ds-normal-aux    as character                no-undo.
        define variable ds-resultado-aux as longchar case-sensitive  no-undo.
        define variable ix               as integer                  no-undo.

        assign ds-especial-aux  = "225,224,227,226,228,233,232,234,235,237,236,238,239,243,242,245,244,246,250,249,252,251,231,241,253,255,193,192,195,194,196,201,200,202,203,205,204,206,207,211,210,213,212,214,218,217,219,220,199,209,221"
               ds-normal-aux    = "97,97,97,97,97,101,101,101,101,105,105,105,105,111,111,111,111,111,117,117,117,117,99,110,121,121,65,65,65,65,65,69,69,69,69,73,73,73,73,79,79,79,79,79,85,85,85,85,67,78,89"
               ds-resultado-aux  = ds-conversao-par.
        
        do ix = 1 to num-entries(ds-normal-aux):                                                                               
            assign ds-resultado-aux = replace(ds-resultado-aux,chr(int(entry(ix,ds-especial-aux,","))),chr(int(entry(ix,ds-normal-aux,",")))).
        end.

        /* --- CARACTERES ACEITOS: A-Z, 0-9, " ", "!", ",", ".", ":", ";", "?", "@" --- */ 
        /* ----------------------- "#", "$", "%", "&", "*", "(", ")", "-", "+", "=" --- */
        /* ----------------------- "{", "}", "[", "]", "<", ">", "/", "~\", "'", """, "_" --- */
        do ix = 1 to length(ds-resultado-aux):

            assign nr-char-aux = keycode(string(substring(ds-resultado-aux,ix,1))).

            if   (nr-char-aux < 97 
            or    nr-char-aux > 122)
            and  (nr-char-aux < 65 
            or    nr-char-aux > 90)
            and  (nr-char-aux < 48 
            or    nr-char-aux > 57)
            and  lookup(string(nr-char-aux),"32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,58,59,60,61,62,63,64,91,92,93,95,123,125") = 0
            then assign ds-resultado-aux = replace(ds-resultado-aux,chr(nr-char-aux),chr(32)).
        end.

        return trim(ds-resultado-aux).                  
    end method.


    /* ------------------------ FUNCAO PARA REMOVER CARACTERES ESPECIAIS -------- */
    method public longchar removeCharEspecialTodos (input ds-conversao-par as longchar).  
        define variable ds-especial-aux  as character                no-undo.
        define variable nr-char-aux      as integer                  no-undo.
        define variable ds-normal-aux    as character                no-undo.
        define variable ds-resultado-aux as longchar case-sensitive no-undo.
        define variable ix               as integer                  no-undo.
        
        assign ds-especial-aux  = "225,224,227,226,228,233,232,234,235,237,236,238,239,243,242,245,244,246,250,249,252,251,231,241,253,255,193,192,195,194,196,201,200,202,03,205,204,206,207,211,210,213,212,214,218,217,219,220,199,209,221,45,47,92,124,35,249,40,95,91,61,239,94,59,46,62,37,42,63,43,44,96,93,60,41,58"
               ds-normal-aux    = "97,97,97,97,97,101,101,101,101,105,105,105,105,111,111,111,111,111,117,117,117,117,99,110,121,121,65,65,65,65,65,69,69,69,69,73,73,73,73,79,79,79,79,79,85,85,85,85,67,78,89,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
               ds-resultado-aux = ds-conversao-par.
        
        do ix = 1 to num-entries(ds-normal-aux):                                                                               
            assign ds-resultado-aux = replace(ds-resultado-aux,chr(int(entry(ix,ds-especial-aux,","))),chr(int(entry(ix,ds-normal-aux,",")))).
        end.

        do ix = 1 to length(ds-resultado-aux):

            assign nr-char-aux = keycode(string(substring(ds-resultado-aux,ix,1))).

            if   (nr-char-aux < 97 
            or    nr-char-aux > 122)
            and  (nr-char-aux < 65 
            or    nr-char-aux > 90)
            and  (nr-char-aux < 48 
            or    nr-char-aux > 57)
            and   nr-char-aux <> 32
            and   nr-char-aux <> 39
            then assign ds-resultado-aux = replace(ds-resultado-aux,chr(nr-char-aux),"").
        end.

        return trim(ds-resultado-aux).
    end method.

    method public longchar validaValoresCampos (input tableHandle as handle):

        define variable ix                     as integer   initial 1 no-undo.
        define variable camposNome             as character extent    no-undo.
        define variable lcValue                as longchar            no-undo.
            
        repeat ix = 1 to tableHandle:num-fields:
        
            if tableHandle:buffer-field(ix):data-type = "Character"
            then assign tableHandle:buffer-field(ix):buffer-value() = removeCharEspecial(tableHandle:buffer-field(ix):buffer-value()).

        end.

        tableHandle:write-json("longchar", lcValue, false, ?, true).
        return lcValue. 

    end method.

    method public rowid convertBase64ToRowid (input cBase64 as character):

        def var iPos as integer no-undo.
        def var mValue as memptr no-undo.
        def var iRem as int no-undo.
        def var iQ as int no-undo.
        def var iRes as int no-undo.
        def var cHexa as char no-undo.
        def var iAsciiValue as int no-undo.

        if cBase64 = ?
        then return ?.

        assign mValue = base64-decode(cBase64).

        do iPos = 1 to get-size(mValue):
            
            assign iAsciiValue = get-byte(mValue, iPos)
                   iRem        = iAsciiValue modulo 16
                   iQ          = (iAsciiValue - iRem) / 16.

            if iQ >= 10 
            then assign iRes = iQ modulo 10
                        cHexa = cHexa + keylabel(keycode("A") + iRes).
            else assign cHexa = cHexa + string(iQ).

            if iRem >= 10 
            then assign iRes  = iRem modulo 10
                        cHexa = cHexa + keylabel(keycode("A") + iRes).
            else assign cHexa = cHexa + string(iRem).

        end.    

        return to-rowid("0x" + lc(cHexa)).
        
    end method.

    method public log gpsLogger():
        return can-find(first param-geral
                        where param-geral.cod-indic-tab = "RC"
                          and param-geral.cod-param     = "gps-logger"
                          and param-geral.des-param     = "1").
    end method.

    method public void programNameToLog():
        def var nr-nivel-aux as int init 1 no-undo.

        repeat while program-name(nr-nivel-aux) <> ?:
            log-manager:write-message("program-name: " + program-name(nr-nivel-aux), "#gps-log").
            assign nr-nivel-aux = nr-nivel-aux + 1.
        end.

    end method.

    /* char | longchar */
    method public void convertToLog(input textoLong as longchar):
        def var indice       as int init 1 no-undo.
        def var tamanho      as int init 0 no-undo.
        def var tamanhoLog   as int init 299 no-undo.

        assign tamanho = length(textoLong).

        repeat:
            log-manager:write-message(string(SUBSTRING(textoLong, tamanhoLog * indice - tamanhoLog + 1, tamanhoLog)), "#gps-log").

            if tamanhoLog * indice > tamanho
            then leave.

            assign indice = indice + 1.
        end.

    end method.

    /* table */
    method public void convertToLog(input hTable as handle):
        def var lcHandle as longchar.

        hTable:write-json("longchar", lcHandle).
        this-object:convertToLog(lcHandle).
    end method.

     /* jsonObject */
    method public void convertToLog(input jObject as jsonObject):
        def var vJsonAsString as longchar no-undo.

        assign vJsonAsString = jObject:GetJsonText().

        this-object:convertToLog(vJsonAsString).

    end method.

    method public void convertToLog(input intObject as int):
        this-object:convertToLog(string(intObject)).
    end method.

    method public void convertToLog(input decObject as dec):
        this-object:convertToLog(string(decObject)).
    end method.

    method public void convertToLog(input lgObject as log):
        this-object:convertToLog(string(lgObject)).
    end method.

    method public void writeXml(input mSource as memptr, input dsFile as character, input dsSrcEncode as character, input dsTarEncode as character):
        def var iPos as int no-undo.
        def var iSize as int no-undo.                        
        def var mTarget as memptr no-undo.        

        assign iSize = get-size(mSource).

        if iSize = 0
        then leave.

        set-size(mTarget) = iSize.
        
        output to value(dsFile)
        CONVERT SOURCE dsSrcEncode TARGET dsTarEncode.

        do iPos = 1 to iSize:
            put unformatted get-string(mSource, iPos, 1).                             
        end.

        output close.

    end method.

    method public memptr putStringAfter(input mSource as memptr, input chSearch as character, input chStringInput as character):
        def var foundExp as log init false no-undo.
        def var iPos as int no-undo.
        def var iSize as int no-undo.
        def var iSizeTarget as int no-undo.            
        def var chPos as char no-undo.
        def var chPosAux as char no-undo.
        def var mTarget as memptr no-undo.
        def var iLenStrInput as int no-undo.
        def var iLenStrSearch as int no-undo.

        assign 
            iLenStrSearch = length(chSearch)
            iLenStrInput = length(chStringInput)
            iSize = get-size(mSource)
            iSizeTarget = iSize + iLenStrInput + iLenStrSearch.

        if iSize = 0
        then return mTarget.

        set-size(mTarget) = iSizeTarget.                        

        do iPos = 1 to iSize:
            assign 
                chPos = get-string(mSource, iPos, 1)
                chPosAux = get-string(mSource, iPos, iLenStrSearch).

            if not foundExp 
            then put-string(mTarget, iPos, 1) = chPos.
            else put-string(mTarget, iPos + iLenStrInput + iLenStrSearch, 1) = chPos.                                            

            if chPosAux = chSearch
            then do:
                assign chPosAux = chPosAux + chStringInput.                                                                
                put-string(mTarget, iPos , iLenStrInput + iLenStrSearch) = chPosAux.                                
                assign 
                    foundExp = true
                    iPos = iPos + iLenStrSearch - 1.
            end.            
        end.                
        
        return mTarget.        

    end method.

    method public logical sendFileToDocumentsCentral(input nmArquivoPar as character):        

        /* Verifica se o arquivo do documento existe */
        if search(nmArquivoPar) = ?
        then return false.            

        /* API responsavel por enviar os documentos para a central */
        run btb/btapi003.p (input nmArquivoPar).

        if return-value = 'NOK' 
        then return false.

    end method.

    method public character normalizaDiretorio(input nm-dir-par as character):
        assign nm-dir-par = replace(nm-dir-par, "~\", "/").
        if r-index(nm-dir-par, "/") < length(nm-dir-par)
        then assign nm-dir-par = nm-dir-par + "/".
        
        return nm-dir-par.

    end method.

end class.
